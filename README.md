# dragkar.github.io


Большинство СКВ систем хранит информацию как список изменений (патчей) для файлов. Эти системы (CVS, Subversion и другие) относятся к хранимым данным как к набору файлов и изменений, сделанных для каждого из этих файлов во времени. Git не хранит свои данные в таком виде. Вместо этого Git считает хранимые данные набором слепков небольшой файловой системы. Каждый раз, когда фиксируется текущая версия проекта, Git сохраняет слепок того, как выглядят все файлы проекта на текущий момент. Ради эффективности, если файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранённый файл. Это важное отличие Git'а от практически всех других систем контроля версий.

[Разработка ПО > Регламент работы с ветками GIT v2.0 > image2018-4-17 8:43:2.png]

               Схема хранения данных в системе GIT

Для совершения большинства операций в Git'е необходимы только локальные файлы и ресурсы, т.е. обычно информация с других компьютеров в сети не нужна. Поскольку вся история проекта хранится локально на диске, большинство операций проходят практически мгновенными. И для того, чтобы  предотвратить потерю данных, Git следит за их целостностью. Перед сохранением любого файла Git вычисляет контрольную сумму, и она становится индексом этого файла. Поэтому невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом. Поэтому после сохранения данные потерять практически невозможно. Узнать подробнее о том, как Git хранит свои данные и как восстановить то, что кажется уже потерянным можно по ссылке.

Стандартный рабочий процесс с использованием Git'а выглядит так:

    Вносятся изменения в файлы в своём рабочем каталоге. 
    Подготовка файлов, путем добавления их слепков в область подготовленных файлов.
    Делается коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение.

  Распределённая система управления версиями Git это инструмент, позволяющий иметь для разработки несколько веток, которые всегда открыты и которые можно использовать для разных стадий  цикла разработки; Git позволяет сливать их одну в другую без особых трудностей.
Модель разработки проекта

      Разработка проекта ведется согласно модели ветвления описанной по ссылке. Перечень веток, которые принято использовать в процессе разработки и их описание представлены в таблице "Правила именования веток".

[Разработка ПО > Регламент работы с ветками GIT v2.0 > image2018-4-17 13:3:5.png]

Модель ветвления

Ветки в проекте именуются в соответствии со следующими правилами

имя ветки	Описание
master	основная ветка, создаётся при инициализации репозитория. Содержит исключительно стабильный код и указывает на последний релиз
develop	основная ветка разработки. Merge всех изменений связанные с новым функционалом совершается сюда.
feature-name	ветки используются для разработки новых функций, которые должны появиться в текущем или будущем релизах
release-x.x.x	ветви релизов  используются для подготовки к выпуску новых версий продукта
hotfix-name	ветви для исправлений используются для подготовки новых выпусков продукта с исправленными замечаниями(ошибками)
Ветвь master


Ветвь разработки(develop)


Ветвь релизов (release)   

Ветка release используются при подготовке к выпуску очередного релиза. Позволяют вносить исправления мелких ошибок, и подготовить метаданные для релиза (номер версии, дата создания и т.д.). Делая все эти действия в ветках release, ветка develop останется чиста, и будет готова к добавлению нового кода, отвечающего непосредственно за расширение функционала разрабатываемого продукта. Создание ветки release производится в тот момент, когда состояние кода в ветке develop отражает желаемое состояние нового релиза

Алгоритм работы с веткой release:

    Создается ветка release с именем, которое не противоречит соглашению о именовании
    В ветку release производится merge ветки develop
    Подготовка проекта к следующему релизу(установка метаданных , решение конфликтов, при возникновении)
    Когда решается, что ветвь release окончательно готова для выпуска, нужно проделать несколько действий. В первую очередь ветвь релиза вливается в главную ветвь (каждый коммит в master — это по определению новый релиз). Далее, этот коммит в master должен быть помечен тегом, чтобы в дальнейшем можно было легко обратиться к любой существовавшей версии продукта. Изменения, сделанные в ветви release, должны быть добавлены обратно в develop, чтобы будущие релизы также содержали внесённые исправления багов.

    Ветвь release удаляется

//создание ветки и клонирование содержимого develop

    git checkout -b release-1.2.0 develop


//Окончание работы с веткой, вливание изменений в ветки master и develop

    git checkout master

    git merge --no-ff release-1.2.0

    git tag -a 1.2.0    //пометка тегом

    git checkout develop
    git merge --no-ff release-1.

Этот шаг может привести к конфликтам во время слияния. Если такое произойдет, то следует исправить конфликты, и зафиксировать изменения.

Флаг --no-ff вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может быть осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, и группирует вместе все внесённые изменения

удаление  ветки release

    git branch -d release-1.2.0

Ветвь функциональностей (feature)

Данная ветка предназначена для разработки нового функционала, который должен появиться в текущем или будущем релизах. Она существует до тех пор, пока ведется разработка нового функционала(при условии, что данная функция должна попасть в текущий релиз, иначе ветка существует в ожидании своего релиза). После того, как новая функция будет добавлен в ветку develop, ветка должна быть удалена.

Алгоритм работы с веткой feature:

    Создание новой ветки с именем, которое не противоречит соглашению о именовании
    Клонируется в созданную ветку содержимое ветки develop
    Новый функционал разрабатывается только в этой ветке
    После завершения работ над функцией надо проверить план внедрения:
        Если не внедряется в следующем релизе, то ветка остается без изменений и ожидает релиза, в котором данная функция внедряется
        Если в следующем релизе происходит внедрение, то содержимое ветки сливается в ветку develop и выполняется пункт 5.

    Ветка feature удаляется

//создание ветки и клонирование в нее состояние develop

    git checkout -b myfeature develop

//Завершение работы с веткой

    git checkout develop
    git merge --no-ff myfeature
    git branch -d myfeature
    git push origin develop

Этот шаг может привести к конфликтам во время слияния. Если такое произойдет, то следует исправить конфликты, и зафиксировать изменения.

удаление  ветки myfeature

    git branch -d myfeature

Ветвь исправлений (hotfix)

Ветка hotfix предназначена  для подготовки к новым не запланированным релизам. Они возникают, из-за необходимости действовать сразу же после обнаружения серьезной ошибки в выпущенном релиза. Ветка hotfix может быть создана ветвлением от коммита в ветке master с меткой текущей production версии. Смысл создания данной ветки заключается в том, чтобы члены команды могли дальше продолжать решение поставленных задач (в ветке develop), в то время как ответственный разработчик будет готовить исправление ошибки в production версии.

Алгоритм работы с веткой hotfix:

    Создание новой ветки с именем, которое не противоречит соглашению о именовании
    Клонируется в созданную ветку содержимое ветки master
    В ветке hotfix производится устранение найденных недоработок
    Сохраняются изменения и вливаются в ветки develop и master
    Ветка hotfix удаляется. 

Примечание: если в данный момент существует ветвь релиза (release), то ветвь исправления (hotfix) должна вливаться в неё, а не в ветвь разработки (develop).

//создание ветки и клонирование в нее состояние master. Необходимо обновление номера версии

    git checkout -b hotfix-1.2.1 master

//Завершение работы с веткой

    git checkout develop

    git merge --no-ff hotfix-1.2.1

Этот шаг может привести к конфликтам во время слияния. Если такое произойдет, то следует исправить конфликты, и зафиксировать изменения.   

Удаление ветки hotfix

    git branch -d hotfix-1.2.1

Правила разрешения конфликтов

magic-magic-magic , в смысле АВАДА КЕДАВРА
Правила оформления коммитов

Каждый коммит должен иметь следующую структуру: "#" + "номер запроса" + "-" +  "цели данного коммита" (Пимер: #SP1234546565-ExampleCommit )
Соглашение о наименовании

    Основная ветка имеет имя master и создается автоматически при инициализации репозитория
    Ветка для разработки должна иметь следующее имя: develop
    Ветки feature и hotfix должны иметь в конце имени номер запроса
    Пример: Example-ExampleTask-SP1234546565
    Ветка feature должна иметь имя следующего вида: feature+ "-name-" + "номер запроса". Пример:
    feature-ExampleTask-SP1234546565 

    Ветка release должна иметь имя следующего вида: release-x1.x2.x3+"-"+* 
     Пример: releae-1.2.3-Example 
    • x1– главный номер версии (major version number).
    • x2 – вспомогательный номер версии (minor version number).
    • x3 – номер сборки, номер логической итерации по работе над функционалом версии x1.x2.(build number)
    Дополнительную информацию можно найти по следующей ссылке


    Ветка  hotfix должна иметь имя следующего вида:  hotfix+ "-name-" + "номер запроса" 
    Пример:  hotfix-ExampleTask-SP1234546565    

Работа с GIT из IDE

    Создание новой ветки

    Открыть вкладку VCS -> Git -> Branches   
    [Разработка ПО > Регламент работы с ветками GIT v2.0 > image2018-4-18 13:40:14.png]  
    Выбрать пункт New Branch, задать имя новой ветке, которое не противоречит соглашению о именовании, и создать новую ветку 

      2. Коммит

    Открыть окно "Commit Changes", ctrl + k или VCS -> Commit Changes
    Выбрать файлы, состояние которых необходимо сохранить
    [Разработка ПО > Регламент работы с ветками GIT v2.0 > image2018-4-18 14:14:32.png]
    ввести сообщение коммита в поле "Commit message"
    нажать кнопку "Commit"

       3. Операции с ветками

    Открыть вкладку VCS -> Git -> Branches
      В окне "Git Branches" нажать на необходимую ветку и в открывшемся меню выбрать необходимый пункт(переход, удалить, создать новую ветку и склонировать состояние выбранной и т.д.)
    [Разработка ПО > Регламент работы с ветками GIT v2.0 > image2018-4-18 14:28:34.png] 

      4. Клонирование состояние другой ветки

    на рабоче области нажать на правую кнопку мыши и вызвать контекстное меню
    в открывшемся меню перейти: Git -> Repository -> Merge Changes...
    [Разработка ПО > Регламент работы с ветками GIT v2.0 > image2018-4-18 14:44:11.png]
    В открывшемся окне выбрать ветку из которой будет взять состояние
    Заполнить поле "Commit"  и нажать на кнопку "Merge"

 



